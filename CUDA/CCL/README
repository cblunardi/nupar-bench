Para executar:
./accl

O benchmark funciona corretamente, gerando sua saida em Data/out1.pgm (gold,cpu) e Data/out2.pgm (gpu) porém não consegui modificar as variáveis que influenciam corretamente a quantia de threads por child kernel. O problema é que todas as informações sobre o funcionamento do benchmark estão inseridas no meio do código, ou seja, 
-> o input é definido por uma imagem .pgm, na main() do arquivo accl_main.cpp, a quantia de frames é definido em nFrames, na mesma função, o tamanho total do input é definido por (FRAMES x ROWS, COLS). ROWS é o tamanho de cada frame. Cada frame é uma imagem por si só que deverá ser analisada separadamente dos outros. 
-> o benchmark executa o ACCL em paralelo (CUDA) e em serial (C) para confrontar os tempos de execução de cada um, MAS não é possível realizar um diff entre os dois pois mesmo que não ocorram erros, os arquivos de saída .pgm diferem já que as cores atribuídas a cada objeto detectado é aleatória para cada execução e para cada frame. Uma possível solução seria de configurar o benchmark para que atribua cores com algum método determinístico e não randômico.
-> o arquivo accl.cu contém os kernels e a função acclCuda() que irá executar alguns kernel pai. O kernel pai é chamado de STREAM, e cada STREAM executa o algoritmo ACCL para um certo número (nFramsPerStream) de FRAMES. Logo, o número de chamadas do kernel pai é igual a FRAMES/STREAM. O default é de 2 frames / stream. O kernel findSpansKernel() não utiliza paralelismo dinâmico, é executado na proporção 1:1 com o kernel pai, que é o mergeSpansKernel.
-> o kernel mergeSpansKernel (STREAM) instancia uma thread para cada um de seus FRAMES. Cada thread instancia ?? instâncias do kernel filho, relabelUnrollKernel, que instancia ROWS*FACTOR*BLOCKSIZE threads. BLOCKSIZE é definido dentro do próprio kernel pai, com valor default igual a blocksize=threads*threads, onde threads=16.
-> tentei modificar o FACTOR por parecer o fator justo que determina o número de threads instanciadas por chamada de child kernels, porém isso me levou a diversos erros estranhos na saída, creio que seja porque o fator FACTOR não influencia o número de child kernels instanciados, somente o workload interno de cada um (número de threads), o que não condiz com o próprio paper, já que este menciona que o motivo do speedup é "Increasing the number of threads for the child kernel reduces the effective number of child kernel launches. This avoids the overhead of launching multiple child kernels on the GPU."
-> a partir disso, tudo me leva a crer que a multiplicidade de threads por child kernel seja influenciada pelo número de FRAMES do input. Porém as entradas disponíveis na pasta do benchmark são 8, enquanto os elementos na tabela apresentada no paper são 10. Talvez o caminho certo seja compreender mais a fundo o mecanismo de SPANS e LABELS. Neste ponto, creio que o mais eficaz seja pedir por email à equipe para que nos diga qual é o magic number deste código.
